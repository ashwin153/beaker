syntax = "proto3";
package beaker.core;

/**
 * A versioned value. Revisions are uniquely-identified and totally-ordered by their version.
 * Revisions are monotonic; if a transaction changes a key for which there exists a newer revision,
 * the modification is discarded.
 *
 * @param version Version number.
 * @param value Value.
 */
message Revision {
  uint64 version = 0;
  string value = 1;
}

/**
 * A conditional update. Transactions depend on the versions of a set of keys, called its readset,
 * and update the revisions of a set of keys, called its writeset. Defaults to an empty transaction.
 *
 * @param depends Version dependencies.
 * @param updates Changed revisions.
 */
message Transaction {
  map<string, uint64> depends = 0;
  map<string, Revision> changes = 1;
}

/**
 * A monotonically-increasing, globally-unique sequence number. Defaults to the zero ballot.
 *
 * @param round Locally-unique number.
 * @param id Globally-unique number.
 */
message Ballot {
  uint32 round = 0;
  uint32 id = 1;
}

/**
 * A collection of non-conflicting transactions. These transactions may conditionally apply updates
 * or unconditionally repair stale revisions. Proposals are uniquely-identified and totally-ordered
 * by their ballot.
 *
 * @param ballot Ballot number.
 * @param commits Transactions to commit.
 * @param repairs Repairs to perform.
 */
message Proposal {
  Ballot ballot = 0;
  repeated Transaction applies = 1;
  Transaction repairs = 2;
}

/**
 * A distributed, transactional key-value store.
 */
service Beaker {

  /**
   * Returns the latest known revision of each key.
   *
   * @param keys Keys to get.
   * @return Revision of each key.
   */
  rpc Get(repeated Key keys) returns (map<Key, Revision>);

  /**
   * Conditionally applies the updates if and only if they depend on the latest versions.
   *
   * @param depends Dependencies.
   * @param updates Updates to apply.
   * @return Whether or not the updates were applied.
   */
  rpc Commit(Transaction) returns (bool);

  /**
   * Makes a promise not to accept any proposal that conflicts with the proposal it returns and has
   * a lower ballot than the proposal it receives. If a promise has been made to a newer proposal,
   * its ballot is returned. If older proposals have already been accepted, they are merged together
   * and returned. Otherwise, it returns the proposal it receives with the default ballot.
   *
   * @param proposal Proposal to prepare.
   * @return Promised proposal.
   */
  rpc Prepare(Proposal) returns (Proposal);

  /**
   * Casts a vote for a proposal if and only if a promise has not been made to a newer proposal.
   *
   * @param proposal Proposal to accept.
   * @return Whether or not the proposal was accepted.
   */
  rpc Accept(Proposal) returns (google.protobuf.Empty);

  /**
   * Votes for a proposal. Beakers commit the transactions and repairs of a proposal once a majority
   * of beakers vote for it.
   *
   * @param proposal Proposal to learn.
   */
  rpc Learn(Proposal) returns (google.protobuf.Empty);

  /**
   *
   */
  rpc Scan(google.protobuf.Empty) returns (stream map<string, Revision>);

}